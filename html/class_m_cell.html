<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>KurusView: MCell Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="kurusview.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">KurusView
   &#160;<span id="projectnumber">1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('class_m_cell.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pro-types">Protected Types</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="class_m_cell-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">MCell Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div>  </div>
</div><!--header-->
<div class="contents">

<p><a class="el" href="class_m_cell.html" title="MCell - Interface (abstract) class for all the cell shapes. ">MCell</a> - Interface (abstract) class for all the cell shapes.  
 <a href="class_m_cell.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_m_cell_8h_source.html">MCell.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for MCell:</div>
<div class="dyncontent">
 <div class="center">
  <img src="class_m_cell.png" usemap="#MCell_map" alt=""/>
  <map id="MCell_map" name="MCell_map">
<area href="class_m_hexahedron.html" title="MHexahedron object - inherits from MCell. " alt="MHexahedron" shape="rect" coords="0,56,92,80"/>
<area href="class_m_pyramid.html" title="MPyramid object - inherits from MCell. " alt="MPyramid" shape="rect" coords="102,56,194,80"/>
<area href="class_m_tetrahedron.html" title="MTetrahedron object - inherits from MCell. " alt="MTetrahedron" shape="rect" coords="204,56,296,80"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a1031f8cfe1e89a20218162d6413131fd"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_cell.html#a1031f8cfe1e89a20218162d6413131fd">getVolume</a> () const </td></tr>
<tr class="memdesc:a1031f8cfe1e89a20218162d6413131fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">get MCellVolume (accessor)  <a href="#a1031f8cfe1e89a20218162d6413131fd">More...</a><br /></td></tr>
<tr class="separator:a1031f8cfe1e89a20218162d6413131fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a198ac6f5bea8bc8525077425201e6ce3"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_cell.html#a198ac6f5bea8bc8525077425201e6ce3">getWeight</a> () const </td></tr>
<tr class="memdesc:a198ac6f5bea8bc8525077425201e6ce3"><td class="mdescLeft">&#160;</td><td class="mdescRight">get MCellWeight (accessor)  <a href="#a198ac6f5bea8bc8525077425201e6ce3">More...</a><br /></td></tr>
<tr class="separator:a198ac6f5bea8bc8525077425201e6ce3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6308f30835ccfea1c9aa2e72ee8f868"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_cell.html#ae6308f30835ccfea1c9aa2e72ee8f868">getID</a> () const </td></tr>
<tr class="memdesc:ae6308f30835ccfea1c9aa2e72ee8f868"><td class="mdescLeft">&#160;</td><td class="mdescRight">get MCellID (accessor)  <a href="#ae6308f30835ccfea1c9aa2e72ee8f868">More...</a><br /></td></tr>
<tr class="separator:ae6308f30835ccfea1c9aa2e72ee8f868"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2dea7dfb6195a67f3093b71d068ee274"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_cell.html#a2dea7dfb6195a67f3093b71d068ee274">getType</a> () const </td></tr>
<tr class="memdesc:a2dea7dfb6195a67f3093b71d068ee274"><td class="mdescLeft">&#160;</td><td class="mdescRight">get MCellType (accessor)  <a href="#a2dea7dfb6195a67f3093b71d068ee274">More...</a><br /></td></tr>
<tr class="separator:a2dea7dfb6195a67f3093b71d068ee274"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3f809c04e1b1ad6d4b0cde3370128eb"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="class_m_vector.html">MVector</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_cell.html#ad3f809c04e1b1ad6d4b0cde3370128eb">getCentreOfGrav</a> () const </td></tr>
<tr class="memdesc:ad3f809c04e1b1ad6d4b0cde3370128eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">get MCellCOG (accessor)  <a href="#ad3f809c04e1b1ad6d4b0cde3370128eb">More...</a><br /></td></tr>
<tr class="separator:ad3f809c04e1b1ad6d4b0cde3370128eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b303927485c96794667164a5f6df5ed"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="class_material.html">Material</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_cell.html#a7b303927485c96794667164a5f6df5ed">getMaterial</a> () const </td></tr>
<tr class="memdesc:a7b303927485c96794667164a5f6df5ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">get MCellMaterial (accessor)  <a href="#a7b303927485c96794667164a5f6df5ed">More...</a><br /></td></tr>
<tr class="separator:a7b303927485c96794667164a5f6df5ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab94c358f78b5f2ee528d941c083b736d"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::shared_ptr&lt; <a class="el" href="class_m_vector.html">MVector</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_cell.html#ab94c358f78b5f2ee528d941c083b736d">getVertices</a> () const </td></tr>
<tr class="memdesc:ab94c358f78b5f2ee528d941c083b736d"><td class="mdescLeft">&#160;</td><td class="mdescRight">get MCellVertices (accessor)  <a href="#ab94c358f78b5f2ee528d941c083b736d">More...</a><br /></td></tr>
<tr class="separator:ab94c358f78b5f2ee528d941c083b736d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf7d14f0c3ec37ed3cc4723422163f72"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; unsigned int &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_cell.html#abf7d14f0c3ec37ed3cc4723422163f72">getVertexIndices</a> ()</td></tr>
<tr class="memdesc:abf7d14f0c3ec37ed3cc4723422163f72"><td class="mdescLeft">&#160;</td><td class="mdescRight">getVertexIndices (accessor)  <a href="#abf7d14f0c3ec37ed3cc4723422163f72">More...</a><br /></td></tr>
<tr class="separator:abf7d14f0c3ec37ed3cc4723422163f72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6926e5a5bf27f677dc38c15bbbc84da"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_cell.html#ac6926e5a5bf27f677dc38c15bbbc84da">setMaterial</a> (std::shared_ptr&lt; <a class="el" href="class_material.html">Material</a> &gt; material)</td></tr>
<tr class="memdesc:ac6926e5a5bf27f677dc38c15bbbc84da"><td class="mdescLeft">&#160;</td><td class="mdescRight">set MCellMaterial accesor  <a href="#ac6926e5a5bf27f677dc38c15bbbc84da">More...</a><br /></td></tr>
<tr class="separator:ac6926e5a5bf27f677dc38c15bbbc84da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f80b850909ed7ea9db8704177b331d5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_cell.html#a3f80b850909ed7ea9db8704177b331d5">setVertices</a> (std::vector&lt; std::shared_ptr&lt; <a class="el" href="class_m_vector.html">MVector</a> &gt;&gt; vertices)</td></tr>
<tr class="memdesc:a3f80b850909ed7ea9db8704177b331d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">set MCellMaterial accesor  <a href="#a3f80b850909ed7ea9db8704177b331d5">More...</a><br /></td></tr>
<tr class="separator:a3f80b850909ed7ea9db8704177b331d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:aeb4799060fa852694769ba92b08af991"><td class="memItemLeft" align="right" valign="top">static double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_cell.html#aeb4799060fa852694769ba92b08af991">getCount</a> ()</td></tr>
<tr class="memdesc:aeb4799060fa852694769ba92b08af991"><td class="mdescLeft">&#160;</td><td class="mdescRight">get MCellInstanceCount (accessor)  <a href="#aeb4799060fa852694769ba92b08af991">More...</a><br /></td></tr>
<tr class="separator:aeb4799060fa852694769ba92b08af991"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-types"></a>
Protected Types</h2></td></tr>
<tr class="memitem:aa5e6a0174cfecba9a4b9b0a62bcbef01"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_cell.html#aa5e6a0174cfecba9a4b9b0a62bcbef01">MCellType_TypeDef</a> { <b>NONE</b>, 
<b>TETRAHEDRON</b>, 
<b>HEXAHEDRON</b>, 
<b>PYRAMID</b>
 }</td></tr>
<tr class="separator:aa5e6a0174cfecba9a4b9b0a62bcbef01"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a49a75fcbf33bb6d83f9fae1acbe39bc9"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_cell.html#a49a75fcbf33bb6d83f9fae1acbe39bc9">MCell</a> (std::vector&lt; std::shared_ptr&lt; <a class="el" href="class_m_vector.html">MVector</a> &gt;&gt; vertices, std::shared_ptr&lt; <a class="el" href="class_material.html">Material</a> &gt; material, long int id)</td></tr>
<tr class="memdesc:a49a75fcbf33bb6d83f9fae1acbe39bc9"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_m_cell.html" title="MCell - Interface (abstract) class for all the cell shapes. ">MCell</a> constructor.  <a href="#a49a75fcbf33bb6d83f9fae1acbe39bc9">More...</a><br /></td></tr>
<tr class="separator:a49a75fcbf33bb6d83f9fae1acbe39bc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac09fa3dd66d4b96eff0ee9ec02b633df"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_cell.html#ac09fa3dd66d4b96eff0ee9ec02b633df">MCell</a> ()=delete</td></tr>
<tr class="memdesc:ac09fa3dd66d4b96eff0ee9ec02b633df"><td class="mdescLeft">&#160;</td><td class="mdescRight">default constructor - deleted  <a href="#ac09fa3dd66d4b96eff0ee9ec02b633df">More...</a><br /></td></tr>
<tr class="separator:ac09fa3dd66d4b96eff0ee9ec02b633df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a942c1b47ed493219ba0a9db7e9641659"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a942c1b47ed493219ba0a9db7e9641659"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_cell.html#a942c1b47ed493219ba0a9db7e9641659">~MCell</a> ()</td></tr>
<tr class="memdesc:a942c1b47ed493219ba0a9db7e9641659"><td class="mdescLeft">&#160;</td><td class="mdescRight">destructor - decrements InstanceCount <br /></td></tr>
<tr class="separator:a942c1b47ed493219ba0a9db7e9641659"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abef50e732986f28c2a740925e63359a7"><td class="memItemLeft" align="right" valign="top">virtual double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_cell.html#abef50e732986f28c2a740925e63359a7">calcVolume</a> () const =0</td></tr>
<tr class="memdesc:abef50e732986f28c2a740925e63359a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">calculates volume of the cell  <a href="#abef50e732986f28c2a740925e63359a7">More...</a><br /></td></tr>
<tr class="separator:abef50e732986f28c2a740925e63359a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5279d7c510ffb1db9402dcf5fd62a1af"><td class="memItemLeft" align="right" valign="top">virtual double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_cell.html#a5279d7c510ffb1db9402dcf5fd62a1af">calcWeight</a> () const =0</td></tr>
<tr class="memdesc:a5279d7c510ffb1db9402dcf5fd62a1af"><td class="mdescLeft">&#160;</td><td class="mdescRight">calculates weight of the cell  <a href="#a5279d7c510ffb1db9402dcf5fd62a1af">More...</a><br /></td></tr>
<tr class="separator:a5279d7c510ffb1db9402dcf5fd62a1af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaafeea0e5385a57631ea6b49124137f2"><td class="memItemLeft" align="right" valign="top">virtual std::shared_ptr&lt; <a class="el" href="class_m_vector.html">MVector</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_cell.html#aaafeea0e5385a57631ea6b49124137f2">calcCentreOfGrav</a> () const =0</td></tr>
<tr class="memdesc:aaafeea0e5385a57631ea6b49124137f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">calculates centre of gravity of the cell  <a href="#aaafeea0e5385a57631ea6b49124137f2">More...</a><br /></td></tr>
<tr class="separator:aaafeea0e5385a57631ea6b49124137f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a21d0c7ac8c78e2203c7910d22d2c908c"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_cell.html#a21d0c7ac8c78e2203c7910d22d2c908c">MCellVolume</a> {}</td></tr>
<tr class="memdesc:a21d0c7ac8c78e2203c7910d22d2c908c"><td class="mdescLeft">&#160;</td><td class="mdescRight">MCellVolume - stores the volume of the cell, can not be set by accessors.  <a href="#a21d0c7ac8c78e2203c7910d22d2c908c">More...</a><br /></td></tr>
<tr class="separator:a21d0c7ac8c78e2203c7910d22d2c908c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7bfe41c202dc0af89eb31a2117a6951"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae7bfe41c202dc0af89eb31a2117a6951"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_cell.html#ae7bfe41c202dc0af89eb31a2117a6951">MCellWeight</a> {}</td></tr>
<tr class="memdesc:ae7bfe41c202dc0af89eb31a2117a6951"><td class="mdescLeft">&#160;</td><td class="mdescRight">MCellWeight - stores the weight of the cell, can not be set by accessors. <br /></td></tr>
<tr class="separator:ae7bfe41c202dc0af89eb31a2117a6951"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14b85fdce4e93b59d7be36d43cb29c0a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a14b85fdce4e93b59d7be36d43cb29c0a"></a>
const long int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_cell.html#a14b85fdce4e93b59d7be36d43cb29c0a">MCellID</a></td></tr>
<tr class="memdesc:a14b85fdce4e93b59d7be36d43cb29c0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">MCellDensity - stores the density of the cell, , can not be set by accessors. <br /></td></tr>
<tr class="separator:a14b85fdce4e93b59d7be36d43cb29c0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abebccf708e72f6f52250936563855576"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::shared_ptr&lt; <a class="el" href="class_m_vector.html">MVector</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_cell.html#abebccf708e72f6f52250936563855576">MCellVertices</a></td></tr>
<tr class="memdesc:abebccf708e72f6f52250936563855576"><td class="mdescLeft">&#160;</td><td class="mdescRight">holds a vector of MVectors defining the vertex of the cell  <a href="#abebccf708e72f6f52250936563855576">More...</a><br /></td></tr>
<tr class="separator:abebccf708e72f6f52250936563855576"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f390f612c718f67578f0f2852b7e605"><td class="memItemLeft" align="right" valign="top">std::vector&lt; unsigned int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_cell.html#a4f390f612c718f67578f0f2852b7e605">vertexIDs</a></td></tr>
<tr class="memdesc:a4f390f612c718f67578f0f2852b7e605"><td class="mdescLeft">&#160;</td><td class="mdescRight">holds a list of all the vertices IDs, populated on construction  <a href="#a4f390f612c718f67578f0f2852b7e605">More...</a><br /></td></tr>
<tr class="separator:a4f390f612c718f67578f0f2852b7e605"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c93c0e60fb016114000aade159d9e75"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3c93c0e60fb016114000aade159d9e75"></a>
std::shared_ptr&lt; <a class="el" href="class_material.html">Material</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_cell.html#a3c93c0e60fb016114000aade159d9e75">MCellMaterial</a></td></tr>
<tr class="memdesc:a3c93c0e60fb016114000aade159d9e75"><td class="mdescLeft">&#160;</td><td class="mdescRight">holds a the material of the cell <br /></td></tr>
<tr class="separator:a3c93c0e60fb016114000aade159d9e75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c67b6979440b9bf61d8b9d97e01f1db"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="class_m_vector.html">MVector</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_cell.html#a6c67b6979440b9bf61d8b9d97e01f1db">MCellCOG</a></td></tr>
<tr class="memdesc:a6c67b6979440b9bf61d8b9d97e01f1db"><td class="mdescLeft">&#160;</td><td class="mdescRight">holds the Centre Of Gravity of the cell as a shared pointer <a class="el" href="class_m_vector.html">MVector</a>  <a href="#a6c67b6979440b9bf61d8b9d97e01f1db">More...</a><br /></td></tr>
<tr class="separator:a6c67b6979440b9bf61d8b9d97e01f1db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf025fa21b527fb4f9ee3e1708ba1e40"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acf025fa21b527fb4f9ee3e1708ba1e40"></a>
<a class="el" href="class_m_cell.html#aa5e6a0174cfecba9a4b9b0a62bcbef01">MCellType_TypeDef</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_cell.html#acf025fa21b527fb4f9ee3e1708ba1e40">MCellType</a></td></tr>
<tr class="memdesc:acf025fa21b527fb4f9ee3e1708ba1e40"><td class="mdescLeft">&#160;</td><td class="mdescRight">MCellType - holds the type of the current cell. <br /></td></tr>
<tr class="separator:acf025fa21b527fb4f9ee3e1708ba1e40"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a0fbede61773b382fed06f29c0392d923"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_cell.html#a0fbede61773b382fed06f29c0392d923">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="class_m_cell.html">MCell</a> &amp;mCell)</td></tr>
<tr class="memdesc:a0fbede61773b382fed06f29c0392d923"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unsure if useful. should perform deep (not shallow) copy to avoid accidental freeing.  <a href="#a0fbede61773b382fed06f29c0392d923">More...</a><br /></td></tr>
<tr class="separator:a0fbede61773b382fed06f29c0392d923"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2ff0e69bbc02553b881696f025d09cc"><td class="memItemLeft" align="right" valign="top">std::ofstream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_cell.html#af2ff0e69bbc02553b881696f025d09cc">operator&lt;&lt;</a> (std::ofstream &amp;os, const <a class="el" href="class_m_cell.html">MCell</a> &amp;mCell)</td></tr>
<tr class="memdesc:af2ff0e69bbc02553b881696f025d09cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">classic friend overloaded ofstream operator&lt;&lt; declaration - prints <a class="el" href="class_m_cell.html" title="MCell - Interface (abstract) class for all the cell shapes. ">MCell</a> properties to file in <a class="el" href="class_model.html" title="Model - This object is responsible for reading and writing model entities to VTK style data files...">Model</a> Loader parser format  <a href="#af2ff0e69bbc02553b881696f025d09cc">More...</a><br /></td></tr>
<tr class="separator:af2ff0e69bbc02553b881696f025d09cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p><a class="el" href="class_m_cell.html" title="MCell - Interface (abstract) class for all the cell shapes. ">MCell</a> - Interface (abstract) class for all the cell shapes. </p>
</div><h2 class="groupheader">Member Enumeration Documentation</h2>
<a class="anchor" id="aa5e6a0174cfecba9a4b9b0a62bcbef01"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="class_m_cell.html#aa5e6a0174cfecba9a4b9b0a62bcbef01">MCell::MCellType_TypeDef</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section note"><dt>Note</dt><dd>when mapping enum to string for printing, make it Compile Time Evaluated (not normal std::map), maybe through constexpr: <a href="https://stackoverflow.com/a/63265237">https://stackoverflow.com/a/63265237</a> #, <a href="https://stackoverflow.com/questions/61281843/creating-compile-time-key-value-map-in-c">https://stackoverflow.com/questions/61281843/creating-compile-time-key-value-map-in-c</a> </dd></dl>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a49a75fcbf33bb6d83f9fae1acbe39bc9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">MCell::MCell </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::shared_ptr&lt; <a class="el" href="class_m_vector.html">MVector</a> &gt;&gt;&#160;</td>
          <td class="paramname"><em>vertices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="class_material.html">Material</a> &gt;&#160;</td>
          <td class="paramname"><em>material</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long int&#160;</td>
          <td class="paramname"><em>id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="class_m_cell.html" title="MCell - Interface (abstract) class for all the cell shapes. ">MCell</a> constructor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vertices</td><td>- the vertex defining the cell </td></tr>
    <tr><td class="paramname">material</td><td>- material of the cell </td></tr>
    <tr><td class="paramname">id</td><td>- unique cell identifier</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Protected accessibility because <a class="el" href="class_m_cell.html" title="MCell - Interface (abstract) class for all the cell shapes. ">MCell</a> is an abstract class. Explicit because Derived class should not be able to hardcode ID - it should come straight from the data file </dd></dl>

</div>
</div>
<a class="anchor" id="ac09fa3dd66d4b96eff0ee9ec02b633df"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">MCell::MCell </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>default constructor - deleted </p>
<dl class="section note"><dt>Note</dt><dd>No such thing as anonymous (ID - less) cells should exist </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="aaafeea0e5385a57631ea6b49124137f2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::shared_ptr&lt;<a class="el" href="class_m_vector.html">MVector</a>&gt; MCell::calcCentreOfGrav </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>calculates centre of gravity of the cell </p>
<dl class="section return"><dt>Returns</dt><dd>shared pointer to anonymous (ID - less) 3D <a class="el" href="class_m_vector.html">MVector</a></dd></dl>
<p>This should probably return weak_ptr - shared_ptr has more overhead. We dont care about the freeing differences as calc* functions are only called internally so at least one instance will exist if the method was called </p>

</div>
</div>
<a class="anchor" id="abef50e732986f28c2a740925e63359a7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual double MCell::calcVolume </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>calculates volume of the cell </p>
<dl class="section return"><dt>Returns</dt><dd>scalar volume of the cell in same unit as cell vectors</dd></dl>
<dl class="section note"><dt>Note</dt><dd>requires shape specific knowledge is to be implemented by derived classes (Pure Virtual) </dd></dl>

</div>
</div>
<a class="anchor" id="a5279d7c510ffb1db9402dcf5fd62a1af"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual double MCell::calcWeight </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>calculates weight of the cell </p>
<dl class="section return"><dt>Returns</dt><dd>scalar weight of the cell - unit dependant on volume and density</dd></dl>
<p>: This one does NOT need to be virtual. </p>

</div>
</div>
<a class="anchor" id="ad3f809c04e1b1ad6d4b0cde3370128eb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="class_m_vector.html">MVector</a> &gt; MCell::getCentreOfGrav </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>get MCellCOG (accessor) </p>
<dl class="section return"><dt>Returns</dt><dd>shared pointer to anonymous (ID - less) 3D <a class="el" href="class_m_vector.html">MVector</a> instance </dd></dl>

</div>
</div>
<a class="anchor" id="aeb4799060fa852694769ba92b08af991"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double MCell::getCount </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>get MCellInstanceCount (accessor) </p>
<dl class="section return"><dt>Returns</dt><dd>MCellInstanceCount copy </dd></dl>

</div>
</div>
<a class="anchor" id="ae6308f30835ccfea1c9aa2e72ee8f868"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double MCell::getID </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>get MCellID (accessor) </p>
<dl class="section return"><dt>Returns</dt><dd>MCellID copy </dd></dl>

</div>
</div>
<a class="anchor" id="a7b303927485c96794667164a5f6df5ed"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="class_material.html">Material</a> &gt; MCell::getMaterial </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>get MCellMaterial (accessor) </p>
<dl class="section return"><dt>Returns</dt><dd>shared pointer to <a class="el" href="class_material.html">Material</a> instance </dd></dl>

</div>
</div>
<a class="anchor" id="a2dea7dfb6195a67f3093b71d068ee274"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::string &gt; MCell::getType </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>get MCellType (accessor) </p>
<dl class="section return"><dt>Returns</dt><dd>Vector of two strings, first element in file format, second in human readable format</dd></dl>
<p>: Implement Compile Time Evaluated mapping, maybe use constexpr array. </p>

</div>
</div>
<a class="anchor" id="abf7d14f0c3ec37ed3cc4723422163f72"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt; unsigned int &gt; &amp; MCell::getVertexIndices </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>getVertexIndices (accessor) </p>
<dl class="section return"><dt>Returns</dt><dd>const reference to vector of unsigned int vector indices</dd></dl>
<dl class="section note"><dt>Note</dt><dd>: const - Returning a mutable reference bypasses protected visibility (Dangerous) </dd></dl>

</div>
</div>
<a class="anchor" id="ab94c358f78b5f2ee528d941c083b736d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::shared_ptr&lt; <a class="el" href="class_m_vector.html">MVector</a> &gt; &gt; MCell::getVertices </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>get MCellVertices (accessor) </p>
<dl class="section return"><dt>Returns</dt><dd>vector of shared pointer to ID represented MVectors </dd></dl>

</div>
</div>
<a class="anchor" id="a1031f8cfe1e89a20218162d6413131fd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double MCell::getVolume </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>get MCellVolume (accessor) </p>
<dl class="section return"><dt>Returns</dt><dd>MCellVolume copy </dd></dl>

</div>
</div>
<a class="anchor" id="a198ac6f5bea8bc8525077425201e6ce3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double MCell::getWeight </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>get MCellWeight (accessor) </p>
<dl class="section return"><dt>Returns</dt><dd>MCellWeight copy </dd></dl>

</div>
</div>
<a class="anchor" id="ac6926e5a5bf27f677dc38c15bbbc84da"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MCell::setMaterial </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="class_material.html">Material</a> &gt;&#160;</td>
          <td class="paramname"><em>material</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>set MCellMaterial accesor </p>
<p>: Do we really need these? - These setters are meant to be used to apply transforms on the object (MColor change, rotation, etc), it is unclear at the moment if they are <em>actually</em> needed, as the transformer - the gpu or some other function could access the memory directly through getVectors(). It probably makes more sense for this class to remain as visualization oriented as possible.</p>
<p>See reverted commit b0e030c for a reference on implementing const methods. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">material</td><td>- a shared pointer to <a class="el" href="class_material.html">Material</a> of the cell </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a3f80b850909ed7ea9db8704177b331d5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MCell::setVertices </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::shared_ptr&lt; <a class="el" href="class_m_vector.html">MVector</a> &gt;&gt;&#160;</td>
          <td class="paramname"><em>vertices</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>set MCellMaterial accesor </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vertices</td><td>- a vector a shared pointer to vertex of the cell </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a class="anchor" id="a0fbede61773b382fed06f29c0392d923"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_m_cell.html">MCell</a> &amp;&#160;</td>
          <td class="paramname"><em>mCell</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unsure if useful. should perform deep (not shallow) copy to avoid accidental freeing. </p>
<p>classic friend overloaded ostream operator&lt;&lt; declaration - prints <a class="el" href="class_m_cell.html" title="MCell - Interface (abstract) class for all the cell shapes. ">MCell</a> properties to stdout in human friendly format </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">os</td><td>- lhs element [ a.operator&lt;&lt;(b) ], might be std::cout or see return </td></tr>
    <tr><td class="paramname">mCell</td><td>- <a class="el" href="class_m_cell.html" title="MCell - Interface (abstract) class for all the cell shapes. ">MCell</a> instance </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>os reference for cascading &lt;&lt; </dd></dl>

</div>
</div>
<a class="anchor" id="af2ff0e69bbc02553b881696f025d09cc"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ofstream&amp; operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ofstream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_m_cell.html">MCell</a> &amp;&#160;</td>
          <td class="paramname"><em>mCell</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>classic friend overloaded ofstream operator&lt;&lt; declaration - prints <a class="el" href="class_m_cell.html" title="MCell - Interface (abstract) class for all the cell shapes. ">MCell</a> properties to file in <a class="el" href="class_model.html" title="Model - This object is responsible for reading and writing model entities to VTK style data files...">Model</a> Loader parser format </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">os</td><td>- lhs element [ a.operator&lt;&lt;(b) ], might be std::cout or see return </td></tr>
    <tr><td class="paramname">mCell</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>os reference for cascading &lt;&lt; </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a class="anchor" id="a6c67b6979440b9bf61d8b9d97e01f1db"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;<a class="el" href="class_m_vector.html">MVector</a>&gt; MCell::MCellCOG</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">mutable</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>holds the Centre Of Gravity of the cell as a shared pointer <a class="el" href="class_m_vector.html">MVector</a> </p>
<dl class="section note"><dt>Note</dt><dd>shared_ptr because Overlapping Cells might share Centre of Gravity </dd></dl>

</div>
</div>
<a class="anchor" id="abebccf708e72f6f52250936563855576"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::shared_ptr&lt;<a class="el" href="class_m_vector.html">MVector</a>&gt; &gt; MCell::MCellVertices</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>holds a vector of MVectors defining the vertex of the cell </p>
<p>color? - check with <a class="el" href="class_material.html">Material</a>. Should be shared_ptr, likely implemented as char array and likely <em>very</em> shared. </p>

</div>
</div>
<a class="anchor" id="a21d0c7ac8c78e2203c7910d22d2c908c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double MCell::MCellVolume {}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">mutable</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>MCellVolume - stores the volume of the cell, can not be set by accessors. </p>
<dl class="section note"><dt>Note</dt><dd>Data Members Volume, Weight, Density use default ctors as they are initialized in the derived class immediately and its cleaner syntax to do it here rather than in the Member Initializer List in some ctor.</dd></dl>
<p>Mutable as they might need to be updated on the background and I want the accessor interface consistently const to not hint on internals </p>

</div>
</div>
<a class="anchor" id="a4f390f612c718f67578f0f2852b7e605"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;unsigned int&gt; MCell::vertexIDs</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>holds a list of all the vertices IDs, populated on construction </p>
<dl class="section note"><dt>Note</dt><dd>std::vector&lt;T&gt; reserves space for two elements by default. On push_back(), a new larger (+1) memory space is reserved if the pushed element doesnt fit. This makes push_back() extremely inefficient if enough space is not reserved from the beginning (eg. 100 push_backs on a default constructed std::vector will run 100 malloc and 100 memmove - they are copied to the new memory space after reserving it ).</dd>
<dd>
The base constructor however does not know how many elements the vertexIDs vector is going to hold because the base class does not know what cell type is being initialized (although the derived class could pass it a flag) the best approach then is to reserve space in the derived constructor. Note, however, that the derived class constructor body runs after the base class constructor is done - and hence the std::vector is allocating memory twice, once in the base class constructor (space for 2) and once in the derived constructor (space for n). Not ideal, but way better than not reserving, and it keeps code simple by not passing flags to the base ctor. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>/home/travis/build/KurusView/2020_GROUP_21/include/<a class="el" href="_m_cell_8h_source.html">MCell.h</a></li>
<li>/home/travis/build/KurusView/2020_GROUP_21/lib/MCell.cpp</li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="class_m_cell.html">MCell</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.11 </li>
  </ul>
</div>
</body>
</html>
